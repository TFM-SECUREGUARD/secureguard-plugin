package com.secureguard.inspections;

import com.intellij.codeInspection.LocalQuickFix;
import com.intellij.codeInspection.ProblemDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.Messages;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import com.secureguard.model.OWASPCategory;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;

/**
 * Quick Fix para mostrar detalles de la vulnerabilidad
 */
class ShowVulnerabilityDetailsQuickFix implements LocalQuickFix {
    private OWASPCategory category;

    // Constructor sin parámetros requerido por IntelliJ
    public ShowVulnerabilityDetailsQuickFix() {
        this.category = OWASPCategory.NONE;
    }

    // Constructor para uso interno
    public ShowVulnerabilityDetailsQuickFix(OWASPCategory category) {
        this.category = category;
    }

    @Nls
    @NotNull
    @Override
    public String getName() {
        return "Show vulnerability details";
    }

    @Nls
    @NotNull
    @Override
    public String getFamilyName() {
        return "SecureGuard Security Analysis";
    }

    @Override
    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
        // Si no tenemos categoría, intentar detectarla del descriptor
        if (category == OWASPCategory.NONE) {
            String description = descriptor.getDescriptionTemplate();
            category = detectCategoryFromDescription(description);
        }

        String details = String.format(
                "%s - %s\n\n%s\n\nRecommendations:\n%s",
                category.getCode(),
                category.getTitle(),
                category.getDescription(),
                getRecommendations()
        );

        Messages.showInfoMessage(project, details, "SecureGuard - Vulnerability Details");
    }

    private OWASPCategory detectCategoryFromDescription(String description) {
        // Intentar detectar la categoría desde la descripción
        for (OWASPCategory cat : OWASPCategory.values()) {
            if (description.contains(cat.getCode()) || description.contains(cat.getTitle())) {
                return cat;
            }
        }
        return OWASPCategory.NONE;
    }

    private String getRecommendations() {
        switch (category) {
            case A03_INJECTION:
                return "• Use parameterized queries or prepared statements\n" +
                        "• Validate and sanitize all user input\n" +
                        "• Use stored procedures where possible";
            case A02_CRYPTOGRAPHIC_FAILURES:
                return "• Use strong algorithms (AES-256, SHA-256)\n" +
                        "• Never use MD5, SHA1, or DES\n" +
                        "• Implement proper key management";
            case A10_SSRF:
                return "• Validate and sanitize URLs\n" +
                        "• Use a whitelist of allowed domains\n" +
                        "• Disable unnecessary URL protocols";
            case A01_BROKEN_ACCESS_CONTROL:
                return "• Implement proper authorization checks\n" +
                        "• Validate file paths to prevent traversal\n" +
                        "• Use principle of least privilege";
            case A07_AUTHENTICATION_FAILURES:
                return "• Never hardcode passwords\n" +
                        "• Use strong password hashing (BCrypt, Argon2)\n" +
                        "• Implement secure session management";
            case A05_SECURITY_MISCONFIGURATION:
                return "• Disable debug features in production\n" +
                        "• Use proper logging frameworks\n" +
                        "• Configure secure headers";
            case A08_SOFTWARE_INTEGRITY_FAILURES:
                return "• Never deserialize untrusted data\n" +
                        "• Implement integrity checks\n" +
                        "• Use secure serialization formats";
            default:
                return "• Review OWASP guidelines for this vulnerability\n" +
                        "• Implement security best practices\n" +
                        "• Consider security code review";
        }
    }
}

/**
 * Quick Fix para SQL Injection
 */
class SQLInjectionQuickFix implements LocalQuickFix {

    // Constructor sin parámetros requerido
    public SQLInjectionQuickFix() {
    }

    @Nls
    @NotNull
    @Override
    public String getName() {
        return "Replace with PreparedStatement";
    }

    @Nls
    @NotNull
    @Override
    public String getFamilyName() {
        return "SecureGuard Security Analysis";
    }

    @Override
    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
        PsiElement element = descriptor.getPsiElement();
        PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);

        if (method == null) return;

        // Buscar Statement vulnerable en el método
        method.accept(new JavaRecursiveElementVisitor() {
            @Override
            public void visitMethodCallExpression(PsiMethodCallExpression expression) {
                super.visitMethodCallExpression(expression);

                String methodName = expression.getMethodExpression().getReferenceName();
                if ("executeQuery".equals(methodName) || "executeUpdate".equals(methodName)) {
                    PsiExpression qualifier = expression.getMethodExpression().getQualifierExpression();
                    if (qualifier != null && qualifier.getText().contains("Statement")) {
                        replaceWithPreparedStatement(project, expression);
                    }
                }
            }
        });
    }

    private void replaceWithPreparedStatement(Project project, PsiMethodCallExpression expression) {
        PsiExpression[] args = expression.getArgumentList().getExpressions();
        if (args.length == 0) return;

        String queryText = args[0].getText();

        String suggestion = String.format(
                "// SECURE: Use PreparedStatement instead\n" +
                        "String query = %s; // TODO: Replace concatenations with ?\n" +
                        "PreparedStatement pstmt = connection.prepareStatement(query);\n" +
                        "// TODO: Set parameters with pstmt.setString(1, value);\n" +
                        "ResultSet rs = pstmt.executeQuery();",
                queryText
        );

        Messages.showInfoMessage(project,
                "Vulnerable SQL query detected. Replace with:\n\n" + suggestion,
                "SecureGuard - SQL Injection Fix");
    }
}

/**
 * Quick Fix para criptografía débil
 */
class WeakCryptoQuickFix implements LocalQuickFix {

    // Constructor sin parámetros requerido
    public WeakCryptoQuickFix() {
    }

    @Nls
    @NotNull
    @Override
    public String getName() {
        return "Use strong cryptography";
    }

    @Nls
    @NotNull
    @Override
    public String getFamilyName() {
        return "SecureGuard Security Analysis";
    }

    @Override
    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
        PsiElement element = descriptor.getPsiElement();
        PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);

        if (method == null) return;

        method.accept(new JavaRecursiveElementVisitor() {
            @Override
            public void visitLiteralExpression(PsiLiteralExpression expression) {
                super.visitLiteralExpression(expression);

                Object value = expression.getValue();
                if (value instanceof String) {
                    String strValue = (String) value;
                    if ("MD5".equals(strValue) || "SHA1".equals(strValue) || "SHA-1".equals(strValue)) {
                        suggestStrongAlgorithm(project, strValue);
                    }
                }
            }
        });
    }

    private void suggestStrongAlgorithm(Project project, String weakAlgorithm) {
        String suggestion;

        switch (weakAlgorithm) {
            case "MD5":
            case "SHA1":
            case "SHA-1":
                suggestion = "Replace '" + weakAlgorithm + "' with 'SHA-256' or 'SHA-512':\n\n" +
                        "MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n" +
                        "For password hashing, use BCrypt:\n" +
                        "BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();\n" +
                        "String hashedPassword = encoder.encode(plainPassword);";
                break;
            default:
                suggestion = "Use strong cryptographic algorithms:\n" +
                        "• SHA-256 or SHA-512 for hashing\n" +
                        "• AES-256 for encryption\n" +
                        "• BCrypt or Argon2 for passwords";
        }

        Messages.showInfoMessage(project, suggestion, "SecureGuard - Strong Cryptography");
    }
}

/**
 * Quick Fix para SSRF
 */
class SSRFValidationQuickFix implements LocalQuickFix {

    // Constructor sin parámetros requerido
    public SSRFValidationQuickFix() {
    }

    @Nls
    @NotNull
    @Override
    public String getName() {
        return "Add URL validation";
    }

    @Nls
    @NotNull
    @Override
    public String getFamilyName() {
        return "SecureGuard Security Analysis";
    }

    @Override
    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
        String validation =
                "// Add URL validation to prevent SSRF\n" +
                        "private static final Set<String> ALLOWED_HOSTS = Set.of(\n" +
                        "    \"api.trusted-domain.com\",\n" +
                        "    \"internal.company.com\"\n" +
                        ");\n\n" +
                        "private void validateURL(String urlString) throws SecurityException {\n" +
                        "    try {\n" +
                        "        URL url = new URL(urlString);\n" +
                        "        String host = url.getHost();\n" +
                        "        \n" +
                        "        if (!ALLOWED_HOSTS.contains(host)) {\n" +
                        "            throw new SecurityException(\"Unauthorized host: \" + host);\n" +
                        "        }\n" +
                        "        \n" +
                        "        // Additional validations\n" +
                        "        if (!url.getProtocol().equals(\"https\")) {\n" +
                        "            throw new SecurityException(\"Only HTTPS allowed\");\n" +
                        "        }\n" +
                        "    } catch (MalformedURLException e) {\n" +
                        "        throw new SecurityException(\"Invalid URL\", e);\n" +
                        "    }\n" +
                        "}";

        Messages.showInfoMessage(project,
                "Add URL validation before making requests:\n\n" + validation,
                "SecureGuard - SSRF Prevention");
    }
}

/**
 * Quick Fix para configuración de seguridad
 */
class SecurityConfigQuickFix implements LocalQuickFix {

    // Constructor sin parámetros requerido
    public SecurityConfigQuickFix() {
    }

    @Nls
    @NotNull
    @Override
    public String getName() {
        return "Fix security configuration";
    }

    @Nls
    @NotNull
    @Override
    public String getFamilyName() {
        return "SecureGuard Security Analysis";
    }

    @Override
    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
        PsiElement element = descriptor.getPsiElement();
        String elementText = element.getText();

        String suggestion = "Security Configuration Best Practices:\n\n";

        if (elementText.contains("printStackTrace")) {
            suggestion += "• Replace printStackTrace() with proper logging:\n" +
                    "  logger.error(\"Error message\", exception);\n\n";
        }

        if (elementText.contains("System.out") || elementText.contains("System.err")) {
            suggestion += "• Use a logging framework instead of System.out:\n" +
                    "  private static final Logger logger = LoggerFactory.getLogger(ClassName.class);\n" +
                    "  logger.info(\"Message\");\n\n";
        }

        suggestion += "• Set appropriate log levels for production\n" +
                "• Avoid exposing sensitive information in logs\n" +
                "• Configure secure error pages";

        Messages.showInfoMessage(project, suggestion, "SecureGuard - Security Configuration");
    }
}